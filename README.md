# Maskash
### 环境配置
注意，各种库所在的目录中不能出现中文字符 / 空格等  
空格会被下面要安装的 GMP 库自动编译代码读到，让代码误以为输入已完成造成编译失败  
#### procps库
1. 安装两个库： sudo apt install libncurses5-dev libncursesw5-dev  
2. sudo apt install procps  
3. sudo apt install libprocps4-dev

#### GMP库
1. sudo apt install m4  
2. 到 https://gmplib.org/ 下载 GMP 包，Maskash 开发团队使用的是6.1.2  
3. 解压后进入 gmp 所在文件夹  
4. $./configure --enable-cxx
5. $make
6. $make check
7. $sudo make install



### 说明文档
                   Libsnark的前世今生
                    应用于一对一匿名交易的零知识证明
       关于匿名交易，最直观的理解就是，在不泄露交易信息的情况下保证交易的成功执行。我们将由浅入深的分析其证明及验证过程:其过程主要基于Libsnark库实现，在此基础上由简至繁，利用最基本的原理，配合匿名交易的具体操作流程，构建出一套用于一对一匿名交易的零知识证明系统。   
       何谓Libsnark？  
       要谈Libsnark,就不得不提到其“灵魂”--------zkSNARK。  zkSNARK是scipr-lab构建的一种非交互式零知识证明系统。而Libsnark正是zkSNARK的实现，一套创造性空前（不一定绝后）的c++库。那么“zkSNARK”到底是怎样一个有趣的灵魂，以至于能托生出Libsnark这样一套牛逼的作品呢？让我们来剖析一下：                                 
       首先来看看其基本原理:ZkSNARK系统中，证明者是通过执行一个可验证的程序VP来证明某种事实，譬如知道某个秘密值x。证明者输入x，执行VP，产生一个证明proof。验证者通过VP和proof，来验证证明者是否知道x，但不知道x是什么。
	   VP是一种公开的特殊的程序，可以用来验证执行者是否真实的执行了这个程序，VP本身不泄露任何秘密，但其实现的算法可以证明执行者是否知道某个秘密。
    譬如程序P：
    boolean function(A,B){
	return(A.B == 0);
    }
       其中A、B为向量，“.”运算为内积计算，那么，在A给定的情况，这个程序可以判定执行者是否知道一个向量B，满足A和B的内积结果为零，程序P本身只是一个计算的表达，不携带秘密信息。
        在P公开，A公开的情况下，如果证明者“诚实的”执行了P，（即执行P，且不篡改P），且诚实的将执行的结果反馈给验证者，那么验证者就可以判断证明者是否拥有符合条件的B（结果为true说明拥有正确的B，结果为false，则不拥有），但证明者不知道B是什么！也就是说证明者向验证者证明了自己拥有正确的B.好！这就是其基本原理。
        而现在的问题是：证明者不一定会是诚实的（譬如，证明者可能直接就给验证者一个true，但自己并没有执行P，也不知道B）！因此，单纯验证程序结果，是不能断定证明者是否真实的执行了程序P、是否真实的知道B的。所以，需要增加额外的工作，让证明者提供一个能证明自己真实执行P的证据proof。为此，就需要对P进行变换，变换为特殊电路、并施加各种操作和密码学工具，最终实现了：验证者可以验证证明是否真实的执行了程序，且不知道任何秘密。Libsnark就是这样的一种实现。
那么具体如何实现呢？我们从最基本的结构来看：  
首先是基本元素：  
（1）整个约束系统构建成一个特殊电路，由放置在“电路板”上的“门”构成，其中：  
门(gadget)：为gadget_xx系列模块，实现特定门的操作。
电路板(board)：为protoboard<FieldT>类型的对象，用来放置gadget。  
（2）那么“门”来自何处呢？门来源于“约束”。  
何谓约束？约束就是输入输出之间的逻辑关系，这种关系的表现形式就是“门”，libsnark中最基本的门是乘法门，其它的门都是以此为基础构建。  
乘法约束：r1cs_constrain(a， b， c)，实现的是a*b=c。  
加法约束：r1cs_constrain(a+b， 1， c)，实现的a+b=c。 

        简单的约束只能完成简单的证明与验证，对于复杂流程的证明验证则需要复杂约束，用一个电路板，调用约束构建，在电路板上“绘制”复杂的电路，可以实现复杂的约束。综上，我们对Libsnark的结构性原理有了一个了解，接下来我们简述一下其具体实现，即构造一个基于Libsnark的匿名交易证明和验证过程。  
        如此一来，我们了解了Libsnark的基本元素构成，是时候讲讲它如何被巧妙地应用到匿名交易上了：  
        根据一对一匿名交易的交易原理，其中每一个基本的算法环节都被构造成一个门电路，进而分别调用函数形成约束并生成参数，整个交易过程用电路实现时，表现为一个大的“门”，由之前构造好的这些小门组成，其约束构造过程也是由这些小门的约束构造函数组成，构造约束调用get_constraint_system()函数。同理，其参数生成过程中的rlcs_witness生成过程也是悉数调用了上面这些小门的参数生成函数。  
        其次是pk、vk，一旦电路板和约束构造成功，则密钥对pk,vk的值确定，其中pk用于生成proof，vk用于验证，这个过程一般要求在可信环境下进行，利用生成的参数及证明这输入的秘密信息，执行计算后可获得输入参数pi和ai，而后，在产生的wittness和pi、ai的基础上，调用r1cs_ppzksnark_prover(…)，获得proof。  
   关于验证，验证过程直接调用验证函数 r1cs_ppzksnark_verifier_strong_IC(…)来执行，此过程中需要用到最初输入的一些参数。  
以上，就是我们从zkSNARK到Libsnark，再到一对一匿名交易的一个过程，这个过程就如同一个充满智慧的灵魂，托生为一个极具天赋的人，而这个人将自己的天赋兑现成了一项伟大的创举。
